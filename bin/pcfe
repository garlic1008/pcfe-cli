#!/usr/bin/env node

const program = require('commander')
const inquirer = require('inquirer')
const homedir = require('os').homedir()
const fs = require('fs')
const path = require('path')
const rimraf = require('rimraf')
const ora = require('ora')
const { promisify: pify } = require('util')
const chalk = require('chalk')
const CFonts = require('cfonts')
const generate = require('../lib/generate')
const www1 = require('../lib/www1')
const Svn = require('../lib/svn')
const {
  getUser,
  generateUserConf
} = require('../lib/userConf')

const { userConf, isComplete } = getUser()

const svn = new Svn(userConf)

const { choose } = require('../lib/confirm')
const semver = require('semver')
const pkg = require('../package.json')
const {
  fail,
  warn,
  info
} = require('../lib/logger')

if (!semver.satisfies(process.version, pkg.engines.node)) {
  warn(chalk.red(`你正在使用 NODE ${process.version}，该工具要求 Node ${pkg.engines.node}，请进行升级，否则可能影响使用`))
}

const TEMPLATE_DIR = path.join(homedir, '.pc-templates')
const TEMPLATE_PREFIX = 'pcfe-'
const TEMPLATE_REG = new RegExp(`^${TEMPLATE_PREFIX}(\\S+)`)

program.option('--offline', '离线模式')

program
  .version(pkg.version, '-v --version')
  .command('create <projectName> [templateName]')
  .option('--offline', '使用离线模板')
  .option('-f --force', '覆盖已存在的项目目录')
  .allowUnknownOption()
  .action(async function (projectName, templateName, cmd) {
    await checkUserConf()

    if (!projectName) {
      fail('缺少项目名')
      process.exit(1)
    }

    try {
      const projectDir = path.resolve(process.cwd(), projectName)
      fs.accessSync(projectDir)
      const override = cmd.force || await choose(`${projectName} 目录已存在，是否覆盖？`, '覆盖', false)

      if (override) {
        const spiner = ora().start()
        await pify(rimraf)(projectDir)
        spiner.stop()
      } else {
        fail('你拒绝了覆盖，任务取消！')
        process.exit(1)
      }
    } catch (error) {
    }

    let template
    if (templateName) {
      try {
        template = await getTemplate(templateName)
      } catch (error) {
        fail(`获取 ${templateName} 模板异常，请确认模板名称或继续使用模板列表选择！`)
      }
    }

    if (!template) {
      const spinner = ora('正在获取模板列表').start()
      try {
        const templateList = await getTemplateList()
        spinner.stop()
        const { templateName } = await inquirer.prompt([{
          type: 'list',
          name: 'templateName',
          message: `正在创建 ${chalk.magenta(projectName)} 项目，请选择模板`,
          choices: templateList
        }])

        template = path.join(TEMPLATE_DIR, templateName)
      } catch (error) {
        spinner.fail('获取不到模板！')
        return console.log(error)
      }
    }

    const _options = {}
    const optionReg = /^--(\S+)/
    const definedOptions = cmd.options.map(o => o.long)
    const { rawArgs } = program
    rawArgs.forEach((a, i) => {
      if (optionReg.test(a) && !definedOptions.includes(a)) {
        const v = rawArgs[++i]
        _options[a.replace(optionReg, '$1')] = v && !optionReg.test(v) ? v : true
      }
    })

    generate(projectName, template, userConf, _options)
  })

program
  .command('list')
  .description('列出模板')
  .option('--offline', '查看离线模板列表')
  .option('-u --update', '查看模板，并更新离线模板')
  .action(async (options) => {
    await checkUserConf()

    const spinner = ora('正在获取模板列表').start()

    let templateList
    try {
      templateList = await getTemplateList()
    } catch (error) {
      fail(error)
      process.exit(1)
    }

    spinner.stop()

    if (templateList) {
      console.log(chalk.green('模板列表：'))
      console.log(`· ${templateList.map(tpl => tpl.name).join('\n· ')}`)
    }
  })

program
  .command('www1 [file...]')
  .description('上传到www1')
  .option('--ignore-config', '忽略配置文件')
  .option('--ignore-cwd', '忽略配置文件中设置的当前工作路径')
  .option('--ignore-dir', '忽略文件夹路径关系，所有文件将在同一路径下')
  .action(async (filepath, options) => {
    try {
      www1(filepath, userConf, options)
    } catch (error) {
      fail(error)
    }
  })

program.on('--help', () => {
  console.log('')
  console.log('Examples:')
  console.log('')
  console.log('  $ custom-help --help')
  console.log('  $ custom-help -h')
})

program.parse(process.argv)

function checkUserConf () {
  if (!isComplete) {
    info('初次使用或用户信息不完整，请完善用户信息！')
    return generateUserConf()
  }
}

async function getTemplate (templateName, offline = program.offline) {
  if (!TEMPLATE_REG.test(templateName)) templateName = TEMPLATE_PREFIX + templateName
  const template = path.resolve(TEMPLATE_DIR, templateName)
  try {
    if (!offline) {
      await svn.export(svn.getSvnUrl(`pc-templates/${templateName}`), template, { force: true })
    }

    fs.accessSync(template)
  } catch (error) {
    error.message = `获取 ${templateName} 模板异常` + error.message
    throw error
  }
  return template
}

async function getTemplateList (offline = program.offline) {
  let templateList, templateDesc
  if (offline) {
    try {
      // fs.accessSync(TEMPLATE_DIR)
      [templateList, templateDesc] = await Promise.all([
        pify(fs.readdir)(TEMPLATE_DIR),
        pify(fs.readFile)(path.join(TEMPLATE_DIR, 'list.json'), 'utf-8')
      ])
    } catch (error) {
      error.message = '获取本地模板出错，请使用线上模式或尝试更新模板\n' + error.message
      throw error
    }
  } else {
    try {
      let list
      [list, templateDesc] = await Promise.all([
        svn.list(svn.getSvnUrl('pc-templates')),
        svn.cat(svn.getSvnUrl('pc-templates/list.json'))
      ])
      templateList = list.list.entry.map(f => f.name)
    } catch (error) {
      error.message = '获取线上模板失败\n' + error.message
      throw error
    }
  }

  templateList = templateList.filter(t => TEMPLATE_REG.test(t))
  try {
    templateDesc = JSON.parse(templateDesc)
  } catch (error) {
    templateDesc = {}
  }

  templateList = templateList.map(t => ({
    name: t.replace(TEMPLATE_REG, '$1') + (templateDesc[t] ? ` ${chalk.gray(templateDesc[t])}` : ''),
    value: t
  }))

  return templateList
}

if (!program.args.length) {
  CFonts.say('pcfe-cli', { colors: ['magenta'] })
  program.help()
}
