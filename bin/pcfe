#!/usr/bin/env node

const program = require('commander')
const inquirer = require('inquirer')
const homedir = require('os').homedir()
const fs = require('fs')
const path = require('path')
const ora = require('ora')
const { promisify: pify } = require('util')
const chalk = require('chalk')
const generate = require('../lib/generate')
const www1 = require('../lib/www1')
const Svn = require('../lib/svn')
const {
  getUser,
  generateUserConf
} = require('../lib/userConf')

const { userConf, isComplete } = getUser()

const svn = new Svn(userConf)

const filterTemplate = require('../lib/filterTemplate')
const { ask } = require('../lib/confirm')
const semver = require('semver')
const pkg = require('../package.json')
const {
  fail,
  warn,
  info
} = require('../lib/logger')

if (!semver.satisfies(process.version, pkg.engines.node)) {
  warn(chalk.red(`你正在使用 NODE ${process.version}，该工具要求 Node ${pkg.engines.node}，请进行升级，否则可能影响使用`))
}

const templateDir = path.join(homedir, '.pc-templates')

program.option('--offline', '离线模式')

program
  .version(pkg.version, '-v --version')
  .usage('[options] <projectName> [templateName]')
  .option('--offline', '使用离线模版')
  .option('-f --force', '覆盖已存在的项目目录')
  .action(async (projectName, ...args) => {
    await checkUserConf()

    if (!projectName) {
      return console.log('缺少项目名')
    }

    try {
      const projectDir = path.join(process.cwd(), projectName)
      fs.accessSync(projectDir)
      const override = await ask(`${projectName} 目录已存在，是否覆盖？`, false)

      if (override) {
        fs.rmdirSync(projectDir)
      } else {
        fail('你拒绝了覆盖，任务取消！')
        process.exit(1)
      }
    } catch (error) {
    }

    let template
    let cmd = {}
    args.forEach(arg => {
      if (typeof arg === 'string') {
        template = path.join(templateDir, arg)
      }
      if (typeof arg === 'object') {
        cmd = arg
      }
    })

    if (template) {
      template = await getTemplate(cmd.offline)
    } else {
      const spinner = ora('正在获取模版列表').start()
      try {
        const templateList = await getTemplateList(cmd.offline)
        spinner.stop()
        const { templateName } = await inquirer.prompt([{
          type: 'list',
          name: 'templateName',
          message: '请选择模版',
          choices: templateList
        }])

        template = path.join(templateDir, templateName)
      } catch (error) {
        spinner.fail('获取不到模版！')
        return console.log(error)
      }
    }

    generate(projectName, template)
  })

program
  .command('list [command]')
  .description('列出模版')
  .option('--offline', '查看离线模版列表')
  .action(async (command) => {
    await checkUserConf()

    let templateList
    if (command === 'update') {
      const spinner = ora('正在更新模版列表').start()
      try {
        await downloadTemplateList()
        spinner.succeed('模版列表更新完成')
      } catch (error) {
        spinner.fail('模版更新失败')
        process.exit(1)
      }

      try {
        templateList = await getOfflineTemplateList()
      } catch (error) {
        templateList = []
      }
    } else {
      const spinner = ora('正在获取模版列表').start()
      const { offline } = program
      try {
        templateList = await getTemplateList(program.offline)
        spinner.stop()
      } catch (error) {
        spinner.fail(offline ? '当前系统不存在模版' : '无法获取线上模版')
        process.exit(1)
      }
    }

    if (templateList) {
      console.log(chalk.green('模版列表：'))
      console.log(`· ${templateList.map(tpl => tpl.name).join('\n· ')}`)
    }
  })

program
  .command('www1 [file]')
  .description('上传到www1')
  .option('--zip', '先打包后再上传')
  .action(async (filepath, option) => {
    // if (!filepath) {
    //   fail('请输入要上传的文件路径！')
    //   program.help()
    // }

    try {
      www1(filepath, userConf, option.zip)
    } catch (error) {
      fail(error)
    }
  })

program.parse(process.argv)

async function checkUserConf () {
  if (!isComplete) {
    info('初次使用或用户信息不完整，请完善用户信息！')
    return generateUserConf()
  }
}

async function getTemplateList (offline) {
  return offline ? getOfflineTemplateList() : getSvnTemplateList()
}

async function downloadTemplateList () {
  return svn.export(svn.getSvnUrl('pc-tempslates'), templateDir, { force: true })
}

async function getTemplate (templateName, offline) {
  if (!offline) {
    await svn.export(svn.getSvnUrl(`pc-tempslates/${templateName}`), path.join(templateDir, templateName), { force: true })
  }
}

function makeTemplateList (templateList, listDesc = {}) {
  return filterTemplate(templateList.map(tpl => ({
    name: `${tpl} ${chalk.gray(listDesc[tpl] || '')}`,
    value: tpl,
    short: tpl
  })))
}

async function getOfflineTemplateList () {
  fs.accessSync(templateDir)
  let templateList, listDesc
  try {
    [templateList, listDesc] = await Promise.all([
      pify(fs.readdir)(templateDir),
      pify(fs.readFile)(path.join(templateDir, 'list.json'), 'utf-8')
    ])
  } catch (error) {
  }

  if (typeof listDesc === 'string') {
    listDesc = JSON.parse(listDesc)
  }

  return makeTemplateList(templateList, listDesc)
}

async function getSvnTemplateList () {
  let [list, listDesc] = await Promise.all([
    svn.list(svn.getSvnUrl('pc-templates')),
    svn.cat(svn.getSvnUrl('pc-templates/list.json'))
  ])

  listDesc = JSON.parse(listDesc)

  const templateList = filterTemplate(list.list.entry
    .map(f => ({
      name: f.name + (listDesc[f.name] ? ` ${chalk.gray(listDesc[f.name])}` : ''),
      value: f.name,
      short: f.name
    })))

  return templateList
}

if (!program.args.length) program.help()
