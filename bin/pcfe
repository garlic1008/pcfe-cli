#!/usr/bin/env node

const program = require('commander')
const homedir = require('os').homedir()
const fs = require('fs')
const path = require('path')
const rimraf = require('rimraf')
const ora = require('ora')
const { promisify: pify } = require('util')
const chalk = require('chalk')
const svn = require('../lib/svn')
const userConfApi = require('../lib/userConfApi')

const { choose } = require('../lib/confirm')
const semver = require('semver')
const pkg = require('../package.json')
const {
  fail,
  warn,
  info
} = require('../lib/logger')

if (!semver.satisfies(process.version, pkg.engines.node)) {
  warn(chalk.red(`你正在使用 NODE ${process.version}，该工具要求 Node ${pkg.engines.node}，请进行升级，否则可能影响使用`))
}

const TEMPLATE_DIR = path.join(homedir, '.pc-templates')
const TEMPLATE_PREFIX = 'pc-'
const TEMPLATE_REG = new RegExp(`^${TEMPLATE_PREFIX}(\\S+)`)

let projectDir = process.cwd()

let { userConf } = userConfApi.getUser()

program.option('--offline', '离线模式')

program
  .version(pkg.version, '-v --version')
  .command('create <projectName> [templateName]')
  .option('--offline', '使用离线模板')
  .option('-f --force', '覆盖已存在的项目目录')
  .allowUnknownOption()
  .action(async function (projectName, templateName, cmd) {
    await checkUserConf()

    if (!projectName) {
      fail('缺少项目名')
      process.exit(1)
    }

    try {
      projectDir = path.resolve(process.cwd(), projectName)
      fs.accessSync(projectDir)
      const override = cmd.force || await choose(`${projectName} 目录已存在，是否覆盖？`, '覆盖', false)

      if (override) {
        const spiner = ora().start()
        await pify(rimraf)(projectDir)
        spiner.stop()
      } else {
        fail('你拒绝了覆盖，任务取消！')
        process.exit(1)
      }
    } catch (error) {
    }

    if (!templateName) {
      const spiner = ora('正在获取模板列表').start()
      try {
        const templateList = await getTemplateList()
        spiner.stop()
        templateName = (await require('inquirer').prompt([{
          type: 'list',
          name: 'templateName',
          message: `正在创建 ${chalk.magenta(projectName)} 项目，请选择模板`,
          choices: templateList
        }])).templateName

        // template = path.join(TEMPLATE_DIR, templateName)
      } catch (error) {
        spiner.fail('获取不到模板！')
        return console.log(error)
      }
    }

    try {
      const template = await getTemplate(templateName)
      const definedOptions = cmd.options.map(o => o.long)

      const _options = getArgOptions(program.rawArgs, definedOptions)

      require('../lib/generate')(projectName, template, userConf, _options)
    } catch (error) {
      fail(`获取 ${templateName} 模板异常，请确认模板名称或继续使用模板列表选择！`)
    }
  })

program
  .command('list')
  .description('列出模板')
  .option('--offline', '查看离线模板列表')
  .option('-u --update', '查看模板，并更新离线模板')
  .action(async (options) => {
    await checkUserConf()
    const spiner = ora().start()

    spiner.text = '正在获取模板'

    let templateList
    try {
      templateList = await getTemplateList()
      if (options.update) {
        spiner.text = '正在更新离线模板'
        await updateLocalTemplates(templateList)
      }
    } catch (error) {
      fail(error)
      process.exit(1)
    }

    spiner.stop()

    if (templateList) {
      console.log(chalk.green('模板列表：'))
      console.log(`· ${templateList.map(tpl => tpl.name).join('\n· ')}`)
    }
  })

program
  .command('www1 [file...]')
  .description('上传到www1')
  .option('--ignore-config', '忽略配置文件')
  .option('--ignore-cwd', '忽略配置文件中设置的当前工作路径')
  .option('--ignore-dir', '忽略文件夹路径关系，所有文件将在同一路径下')
  .action(async (filepath, options) => {
    try {
      require('../lib/www1')(filepath.length ? filepath : null, userConf, projectDir, options)
    } catch (error) {
      fail(error)
    }
  })

program
  .command('serve [baseDir]')
  .option('-p --port', '指定要使用的端口')
  .option('--open', '是否自动打开链接')
  .action((baseDir, options) => {
    try {
      baseDir = baseDir || 'src'
      fs.accessSync(baseDir)
      const { port, open } = options
      require('browser-sync').create().init({
        watch: true,
        injectChanges: true, // 插入更改
        files: ['*.html', '*.css', '*.js'],
        server: {
          baseDir
        },
        logPrefix: 'pcfe serve',
        open: typeof open === 'undefined' ? true : open,
        port: port || '9000'
      })
    } catch (error) {
      fail(error)
      process.exit(1)
    }
  })

program
  .command('user')
  .option('--set <key> <value>', '设置用户配置中指定参数的指')
  .option('--get <key>', '获取用户配置中指定参数的指')
  .option('-d --delete <key>', '删除用户配置中指定参数的指')
  .option('-l --list', '展示用户配置')
  .option('--check', '验证账号是否正确并保存至配置文件中')
  .option('--check-svn', '验证 svn 账号是否正确并保存至配置文件中')
  .option('--reset', '对用户配置进行重设')
  .option('--no-store', '验证账号时不保存配置文件')
  .action((...args) => {
    const options = args.pop()

    let _args = []

    if (!options.store) {
      _args = [false]
    }
    delete options.store

    const funKeys = Object.keys(options).filter(k => !!userConfApi[k])

    if (funKeys.length === 1) {
      const funKey = funKeys[0]
      const fun = userConfApi[funKey]

      if (typeof fun === 'function') {
        if (typeof options[funKey] === 'string') {
          _args = [options[funKey]]
        }

        if (args.length) {
          _args = _args.concat(args.slice(0, args.length - 1))
        }

        fun.apply(userConf, _args).catch(err => {
          console.log(1, err)
        })
      }
    }
  })

program.on('--help', () => {
  console.log('')
  console.log('Examples:')
  console.log('')
  console.log('  $ custom-help --help')
  console.log('  $ custom-help -h')
})

program.parse(process.argv)

/* if (['user', 'u'].includes(program.args[0])) {
  const { args } = program
  const rawArgs = program.rawArgs.slice(2).filter(a => !args.includes(a))

  const options = getArgOptions(rawArgs)

  const fun = userConfApi[args[1]]

  const outHelp = function (err) {
    err && fail(err.message)
    console.log(`pcfe user set <key> <value>           设置用户配置中指定参数的指
pcfe user get <key>                   获取用户配置中指定参数的指
pcfe user delete <key>                删除用户配置中指定参数的指
pcfe user list                        展示用户配置
pcfe user check [--svn] [--no-store]  验证账号或 svn 账号是否正确,正确时默认自动存储
pcfe user reset                       对用户配置进行重设`)
    process.exit(1)
  }

  if (typeof fun !== 'function') {
    outHelp()
  }

  fun.apply(userConf, [...args.slice(2), options]).catch(outHelp)
} */

function getArgOptions (args, ignoreOptions = []) {
  const optionReg = /^--(\S+)/
  const options = {}
  args.forEach((a, i) => {
    if (optionReg.test(a) && !ignoreOptions.includes(a)) {
      const v = args[++i]
      options[a.replace(optionReg, '$1')] = v && !optionReg.test(v) ? v : true
    }
  })
  return options
}

async function checkUserConf () {
  let { userConf: _userConf, isComplete } = userConfApi.getUser()
  if (!isComplete) {
    info('初次使用或用户信息不完整，请完善用户信息！')
    _userConf = await userConfApi.checkMissing()
  }

  userConf = _userConf
  svn.init(Object.assign({}, userConf, { baseUrl: svn.getTplUrl() }))
}

async function getTemplate (templateName, offline = program.offline) {
  if (!TEMPLATE_REG.test(templateName)) templateName = TEMPLATE_PREFIX + templateName
  const template = path.resolve(TEMPLATE_DIR, templateName)
  try {
    if (!offline) {
      await svn.export(svn.getTplUrl(`${templateName}`), template, { force: true })
    }

    fs.accessSync(template)
  } catch (error) {
    error.message = `获取 ${templateName} 模板异常` + error.message
    throw error
  }

  return template
}

async function getTemplateList (offline = program.offline) {
  let templateList, templateDesc
  if (offline) {
    try {
      // fs.accessSync(TEMPLATE_DIR)
      [templateList, templateDesc] = await Promise.all([
        pify(fs.readdir)(TEMPLATE_DIR),
        pify(fs.readFile)(path.join(TEMPLATE_DIR, 'list.json'), 'utf-8')
      ])
    } catch (error) {
      error.message = '获取本地模板出错，请使用线上模式或尝试更新模板\n' + error.message
      throw error
    }
  } else {
    try {
      let list
      [list, templateDesc] = await Promise.all([
        svn.list(svn.getTplUrl()),
        svn.cat(svn.getTplUrl('list.json'))
      ])
      templateList = list.list.entry.map(f => f.name)
    } catch (error) {
      error.message = '获取线上模板失败\n' + error.message
      throw error
    }
  }

  templateList = templateList.filter(t => TEMPLATE_REG.test(t))
  try {
    templateDesc = JSON.parse(templateDesc)
  } catch (error) {
    templateDesc = {}
  }

  templateList = templateList.map(t => ({
    name: t.replace(TEMPLATE_REG, '$1') + (templateDesc[t] ? ` ${chalk.gray(templateDesc[t])}` : ''),
    value: t
  }))

  return templateList
}

async function updateLocalTemplates (templateList) {
  const queue = templateList.map(t => getTemplate(t.value, false))
  return Promise.all(queue)
}

if (!program.args.length) {
  require('cfonts').say('pcfe-cli', { colors: ['magenta'] })
  program.help()
}
